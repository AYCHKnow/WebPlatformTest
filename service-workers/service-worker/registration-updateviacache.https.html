<!DOCTYPE html>
<title>Service Worker: Registration-updateViaCache</title>
<script src="/resources/testharness.js"></script>
<script src="resources/testharness-helpers.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="resources/test-helpers.sub.js"></script>
<script>
  const updateViaCacheValues = [undefined, 'imports', 'all', 'none'];
  const scriptUrl = 'resources/update-max-aged-worker.py';
  const scope = 'resources/blank.html';

  async function cleanup() {
    const reg = await navigator.serviceWorker.getRegistration(scope);
    if (!reg) return;
    if (reg.scope == new URL(scope, location).href) {
      return reg.unregister()
    };
  }

  function wait(ms) {
    return new Promise(r => setTimeout(r, ms));
  }

  function waitForActivated(sw) {
    return new Promise((resolve, reject) => {
      function check() {
        if (sw.state == 'activated') {
          sw.removeEventListener('statechange', check);
          resolve();
          return;
        }
        if (sw.state == 'redundant') {
          sw.removeEventListener('statechange', check);
          reject(Error('Service worker rejected'));
          return;
        }
      }

      sw.addEventListener('statechange', check);
      check();
    });
  }

  function getScriptTimes(sw, testName) {
    return new Promise(resolve => {
      navigator.serviceWorker.addEventListener('message', function listener(event) {
        if (event.data.test !== testName) return;
        navigator.serviceWorker.removeEventListener('message', listener);
        resolve({
          mainTime: event.data.mainTime,
          importTime: event.data.importTime
        });
      });

      sw.postMessage('');
    });
  }

  function registerViaApi(scriptUrl, opts) {
    return navigator.serviceWorker.register(scriptUrl, opts);
  }

  async function registerViaLinkElement(scriptUrl, opts) {
    const link = document.createElement('link');

    if (link.relList.supports('serviceworker') == false) throw Error("link rel=serviceworker not supported");

    link.rel = 'serviceworker';
    link.href = scriptUrl;
    link.scope = opts.scope;

    if (opts.updateViaCache) {
      link.updateViaCache = opts.updateViaCache;
    }

    document.head.appendChild(link);

    const fullScope = new URL(opts.scope, window.location).href;

    while (true) {
      const regs = await navigator.serviceWorker.getRegistrations();
      const reg = regs.find(r => r.scope == fullScope && (r.installing || r.waiting || r.active));

      if (reg) {
        document.head.removeChild(link);
        return reg;
      }

      await wait(100);
    }
  }

  async function registerViaLinkHeader(scriptUrl, opts) {
    const link = document.createElement('link');

    const fullScope = new URL(opts.scope, window.location).href;
    scriptUrl = new URL(scriptUrl, location).href;

    // Assuming that if this isn't supported, the header isn't
    if (link.relList.supports('serviceworker') == false) throw Error("link rel=serviceworker not supported");

    let linkHeader = `<${scriptUrl}>; rel=serviceworker; scope="${fullScope}"`;

    if (opts.updateViaCache) {
      linkHeader += `; updateviacache="${opts.updateViaCache}"`;
    }

    const url = new URL('resources/link-header.py', location);
    url.searchParams.set('Link', linkHeader);

    const frame = await with_iframe(url);

    while (true) {
      const regs = await navigator.serviceWorker.getRegistrations();
      const reg = regs.find(r => r.scope == fullScope && (r.installing || r.waiting || r.active));

      if (reg) {
        frame.parentNode.removeChild(frame);
        return reg;
      }

      await wait(100);
    }
  }

  const registrationMethods = [
    [registerViaApi, 'via-api'],
    [registerViaLinkElement, 'via-link-element'],
    [registerViaLinkHeader, 'via-link-header']
  ];

  // Testing creating registrations
  for (const [registrationMethod, registrationMethodName] of registrationMethods) {
    for (const updateViaCache of updateViaCacheValues) {
      const testName = `register-${registrationMethodName}-updateViaCache-${updateViaCache}`;

      promise_test(async () => {
        await cleanup();

        const opts = {scope};

        if (updateViaCache) opts.updateViaCache = updateViaCache;

        const reg = await registrationMethod(
          `${scriptUrl}?test=${testName}`,
          opts
        );

        const sw = reg.installing || reg.waiting || reg.active;
        if (!sw) console.log(reg);
        await waitForActivated(sw);
        const values = await getScriptTimes(sw, testName);
        await reg.update();

        if (updateViaCache == 'all') {
          assert_equals(reg.installing, null, "No new service worker");
        }
        else {
          const newWorker = reg.installing;
          assert_true(!!newWorker, "New worker installing");
          const newValues = await getScriptTimes(newWorker, testName);

          if (!updateViaCache || updateViaCache == 'imports') {
            assert_not_equals(values.mainTime, newValues.mainTime, "Main script should have updated");
            assert_equals(values.importTime, newValues.importTime, "Imported script should be the same");
          }
          else { // 'none'
            assert_not_equals(values.mainTime, newValues.mainTime, "Main script should have updated");
            assert_not_equals(values.importTime, newValues.importTime, "Imported script should have updated");
          }
        }

        await cleanup();
      }, testName);
    }
  }

  // Testing changing registration
  for (const updateViaCache1 of updateViaCacheValues) {
    for (const updateViaCache2 of updateViaCacheValues) {
      const testName = `register-with-updateViaCache-${updateViaCache1}-then-${updateViaCache2}`;

      promise_test(async () => {
        await cleanup();

        const fullScriptUrl = `${scriptUrl}?test=${testName}`;
        let opts = {scope};
        if (updateViaCache1) opts.updateViaCache = updateViaCache1;

        const reg = await navigator.serviceWorker.register(fullScriptUrl, opts);

        const sw = reg.installing;
        await waitForActivated(sw);
        const values = await getScriptTimes(sw, testName);

        opts = {scope};
        if (updateViaCache2) opts.updateViaCache = updateViaCache2;

        await navigator.serviceWorker.register(fullScriptUrl, opts);

        // If there's no change, register should be a no-op.
        // The default value should behave as 'imports'.
        if ((updateViaCache1 || 'imports') == (updateViaCache2 || 'imports')) {
          assert_equals(reg.installing, null, "No new service worker");
        }
        else {
          const newWorker = reg.installing;
          assert_true(!!newWorker, "New worker installing");
          const newValues = await getScriptTimes(newWorker, testName);

          if (updateViaCache2 == 'all') {
            assert_equals(values.mainTime, newValues.mainTime, "Main script should be the same");
            assert_equals(values.importTime, newValues.importTime, "Imported script should be the same");
          }
          else if (updateViaCache2 == 'imports') {
            assert_not_equals(values.mainTime, newValues.mainTime, "Main script should have updated");
            assert_equals(values.importTime, newValues.importTime, "Imported script should be the same");
          }
          else { // 'none'
            assert_not_equals(values.mainTime, newValues.mainTime, "Main script should have updated");
            assert_not_equals(values.importTime, newValues.importTime, "Imported script should have updated");
          }
        }

        await cleanup();
      }, testName);
    }
  }

</script>
